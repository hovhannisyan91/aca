<html>

<head>
    <meta charset="utf-8">
    <title>Special Topics In SQL</title>
    <meta name="author" content="Karen Hovhannisyan">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/simple.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai-sublime.css">
    <!-- DM Sans font -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        /* Global font */
        * {
            font-family: 'DM Sans';
            text-align: left;
        }


        .new-section {
            text-align: center;
            font-weight: bold;
        }

        h3 {
            /* margin-bottom: 20px; */
            font-weight: bold;
        }

        .split {
            display: flex;
            gap: 10px;
            height: 100%;
            align-items: center;
            justify-content: center;
        }

        .split>div {
            flex: 1;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            color: #fff;
            /* white text for contrast */
            font-weight: bold;
        }

        /* Different colors for each child */
        .split>div:nth-child(1) {
            background-color: #1abc9c;
        }

        /* teal */
        .split>div:nth-child(2) {
            background-color: #3498db;
        }

        /* blue */
        .split>div:nth-child(3) {
            background-color: #9b59b6;
        }

        /* purple */
        .split>div:nth-child(4) {
            background-color: #e67e22;
        }

        /* orange */
        .split>div:nth-child(5) {
            background-color: #e74c3c;
        }

        /* red */
    </style>
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <script>
        function displayDate() {
            const today = new Date();
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            // Use 'en-GB' for European style (day before month), but format as requested
            let date = today.toLocaleDateString('en-GB', options);
            // Remove the comma before the year if present
            date = date.replace(/, (\d{4})$/, ' $1');
            document.getElementById("current-date").innerHTML = date;
        }
    </script>

    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
</head>

<body onload="displayDate()">
    <div class="reveal">

        <!-- Any section ment inside of this container is displayed as a slide -->
        <div class="slides">


            <!-- Slide 1 -->
            <section>
                <h3 class="r-fit-text">Stored Procedures and User Defined Functions in PostgreSQL</h3>
                <br><br>
                <i>
                    <h6 style="text-align: center;">Karen Hovhannisyan</h6>
                </i>
                <i>
                    <h6 style="text-align: center;"><span id="current-date"></span></h6>
                </i>
            </section>

            <!-- About Me Section -->
            <section>
                <!-- Slide 2 -->
                <section id="about-01" class="new-section">
                    <h3>A little bit about me...</h3>
                </section>
                <!-- Slide 3 -->
                <section id="about-me">
                    <h3>About Me</h3>
                    <!-- TODO: adding about me context   -->
                    <img src="img/qr_linkedin.png" alt="logo"
                        style="position: absolute; top: 20px; right: 20px; width: 80px; height: auto;">

                </section>

            </section>

            <!-- Agenda -->
            <!-- Slide 4 -->
            <section>
                <h3>Objective</h3>
                <ul class="r-fit-text">
                    <li>What are Stored Procedures and User Defined Functions?</li>
                    <li><b>When</b> and <b>Why</b> to use each Stored Procedures and UDFs?</li>
                    <li>Creating Stored Procedures in PostgreSQL</li>
                    <li>Creating User Defined Functions in PostgreSQL</li>
                    <li>Examples and Use Cases</li>
                    <li>Q&A</li>
                </ul>
            </section>

            <!-- Stored Procedures -->
            <section>
                <!--! ===================== Stored Procedures ===================== -->
                <section>
                    <h3 class="new-section">Stored Procedures (SPs)</h3>
                </section>

                <!-- ===================== sp-01: Definition ===================== -->
                <section id="sp-01">
                    <h3>Definition</h3>
                    <p class="r-fit-text">
                        <b>A Stored Procedure</b> is a precompiled collection of SQL statements and optional
                        control-of-flow logic
                        (loops, conditionals) stored inside the database.
                    </p>
                    <ul class="r-fit-text">
                        <li>Executed on demand by calling its name</li>
                        <li>
                            It can
                            <span class="fragment" data-fragment-index="1"><b>accept input parameters</b></span>,
                            <span class="fragment" data-fragment-index="2"><b>return output parameters</b></span>,
                            <span class="fragment" data-fragment-index="3">and/or <b>return result sets</b></span>
                        </li>
                    </ul>
                </section>

                <!-- ===================== sp-02: Why to use Stored Procedures ===================== -->
                <section id="sp-02">
                    <h3>Why use Stored Procedures?</h3>
                    <ul class="r-fit-text">
                        <li><b>Encapsulation:</b> Centralize business logic with a stable interface</li>
                        <li><b>Performance:</b> Fewer client↔DB round-trips</li>
                        <li><b>Reusability:</b> Call from multiple apps and contexts</li>
                        <li><b>Maintainability:</b> Update logic in one place</li>
                        <li><b>Security:</b> Grant <code>EXECUTE</code> instead of direct table DML</li>
                    </ul>
                </section>

                <!-- ===================== sp-03: Pseudocode + Execution ===================== -->
                <section id="sp-03">
                    <h3>Pseudocode</h3>
                    <pre><code class="language-sql">
-- Stored Procedure (pseudocode)
CREATE PROCEDURE procedure_name (parameters)
AS
BEGIN
    -- SQL statements
    -- Control flow (IF, LOOP, etc.)
    -- Business logic
END;
        </code></pre>

                    <p class="fragment">Execution</p>
                    <pre class="fragment"><code class="language-sql">
-- Execute a stored procedure (generic form)
EXECUTE/CALL procedure_name(param_values...);
        </code></pre>
                </section>

                <!-- ===================== sp-04: CREATE (Insert) ===================== -->
                <section id="sp-04">
                    <h3 class="r-fit-text">Creating Stored Procedures | INSERT</h3>
                    <pre><code class="language-sql">

CREATE OR REPLACE PROCEDURE add_customer(
    p_customer_id   INT,
    p_customer_name TEXT,
    p_address       TEXT,
    p_city          TEXT,
    p_zip           TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO customers(customer_id, customer_name, address, city, zip_code)
    VALUES (p_customer_id, p_customer_name, p_address, p_city, p_zip);
END;
$$;

-- CALL add_customer(10001, 'John Doe', '123 Main St', 'Yerevan', '0010');
        </code></pre>
                </section>

                <!-- ===================== sp-05: READ (Select via OUT params) ===================== -->
                <section id="sp-05">
                    <h3 class="r-fit-text">Creating Stored Procedures | SELECT</h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE PROCEDURE get_customer(
    p_customer_id INT,
    OUT o_name    TEXT,
    OUT o_city    TEXT,
    OUT o_zip     TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    SELECT customer_name, city, zip_code
      INTO o_name, o_city, o_zip
      FROM customers
     WHERE customer_id = p_customer_id;
END;
$$;

-- CALL get_customer(10001, NULL, NULL, NULL);
        </code></pre>
                </section>

                <!-- ===================== sp-06: UPDATE ===================== -->
                <section id="sp-06">
                    <h3 class="r-fit-text">Creating Stored Procedures | UPDATE</h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE PROCEDURE update_product_price(
    p_product_id INT,
    p_new_price  NUMERIC
)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE products
       SET price = p_new_price
     WHERE product_id = p_product_id;
END;
$$;

-- CALL update_product_price(2001, 19.99);
        </code></pre>
                </section>

                <!-- ===================== sp-07: DELETE ===================== -->
                <section id="sp-07">
                    <h3 class="r-fit-text">Creating Stored Procedures | DELETE</h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE PROCEDURE delete_order_safe(p_order_id INT)
LANGUAGE plpgsql
AS $$
BEGIN
    -- First delete dependent sales rows (FK ON DELETE RESTRICT)
    DELETE FROM sales  WHERE order_id = p_order_id;

    -- Then delete the order itself
    DELETE FROM orders WHERE order_id = p_order_id;
END;
$$;
        </code></pre>
                </section>

                <!-- ===================== sp-08: Beyond CRUD — Batch / ETL ===================== -->
                <section id="sp-08">
                    <!-- TODO SIMPLER QUERY -->
                    <h3>What else<span>?</span> <span class="fragment">Batch / ETL Workflow</span></h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE PROCEDURE load_monthly_sales(
    month_start DATE, month_end DATE
)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO sales_fact(order_id, product_id, customer_id, total_sales)
    SELECT o.order_id, s.product_id, s.customer_id, SUM(s.total_sales)
    FROM orders o
    JOIN sales  s ON s.order_id = o.order_id
    WHERE o.order_date >= month_start
    AND o.order_date <  month_end
    GROUP BY o.order_id, s.product_id, s.customer_id;
END;
$$;

-- CALL load_monthly_sales('2025-08-01','2025-09-01');
        </code></pre>
                </section>

                <!-- ===================== sp-09: Transactions & Error Handling ===================== -->
                <section id="sp-09">
                    <h3>Transactions & Error Handling</h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE PROCEDURE transfer_credit(
    from_emp INT, to_emp INT, amt NUMERIC
)
LANGUAGE plpgsql
AS $$
BEGIN
    IF amt &lt;= 0 THEN
        RAISE EXCEPTION 'Amount must be positive';
    END IF;

    UPDATE employees SET salary = salary - amt WHERE employee_id = from_emp;
    IF NOT FOUND THEN RAISE EXCEPTION 'Sender % not found', from_emp; END IF;

    UPDATE employees SET salary = salary + amt WHERE employee_id = to_emp;
    IF NOT FOUND THEN RAISE EXCEPTION 'Receiver % not found', to_emp; END IF;

    -- Optional: explicit transaction control when procedure is the unit of work
    -- COMMIT;
EXCEPTION WHEN OTHERS THEN
    -- ROLLBACK;
    RAISE;
END;
$$;

-- CALL transfer_credit(1, 2, 100);
        </code></pre>
                </section>





                <!-- ===================== sp-11: Nuances & Caveats ===================== -->
                <section id="sp-12">
                    <h3>Risks</h3>
                    <ul class="r-fit-text">
                        <li class="fragment"><b>Portability:</b> Syntax differs across DBs (PL/pgSQL vs T-SQL vs PL/SQL)
                        </li>
                        <li class="fragment"><b>Versioning:</b> Keep procedures in migrations; document parameters &
                            behavior</li>
                        <li class="fragment"><b>Overuse Risk:</b> Avoid DB-monolith; balance with app layer / dbt</li>
                        <li class="fragment"><b>Observability:</b> Add auditing/logging where appropriate</li>
                    </ul>
                </section>

                <!-- ===================== sp-13: Best Practices ===================== -->
                <section id="sp-13">
                    <h3>Best Practices</h3>
                    <ul class="r-fit-text">
                        <li>Keep procedures small and modular</li>
                        <li>Use meaningful, action-oriented names</li>
                        <li>Prefer set-based logic over row-by-row loops</li>
                        <li>Validate inputs; fail fast with clear messages</li>
                        <li>Document parameters, side effects, and expected outcomes</li>
                    </ul>
                </section>
            </section>


            <!--! New Section UDF -->
            <section>
                <section>
                    <h3 class="new-section">User Defined Functions (UDFs)</h3>
                </section>
                <section id="udf-01">
                    <h3>Definition | Function</h3>
                    <p class="r-fit-text">A named block of code that performs a specific task, by taking an input
                        parameters, processing them and return an output</p>
                    <pre><code class="python">
function add(a, b):
    return a + b

x = add(2, 3)  --> returns 5

                </code></pre>

                </section>
                <section id="udf-01">
                    <h3>Definition | UDF</h3>
                    <p class="r-fit-text">A User-Defined Function (UDF) is a function that you (the user) create inside
                        the DB.</p>
                    <p class="r-fit-text">Unlike built-in functions <code>(SUM(), AVG(), NOW())</code>, UDFs let you extend
                        SQL with custom logic, liv inside the database, so they can be used in queries, <b>WHERE, JOINs,
                            SELECTs</b> statements</p>
                    <pre><code class="python">
function add(a, b):
    return a + b

x = add(2, 3)  --> returns 5

                </code></pre>

                </section>
                <section id="udf-02">
                    <h3>Why Do We Need UDFs?</h3>
                    <ul class="r-fit-text">
                        <li><b>Encapsulation of Logic:</b> Instead of repeating formulas everywhere, define them once as
                            a function.</li>
                        <li><b>Consistency:</b> Ensures all queries use the same rule.</li>
                        <li><b>Maintainability:</b> Makes SQL queries shorter and easier to understand.</li>
                        <li><b>Performance:</b> SQL-language UDFs can be inlined and optimized by DB</li>
                    </ul>
                </section>
                <section id="udf-03">
                    <h3>UDF Types</h3>
                    <ul class="r-fit-text">
                        <li><b>Scalar Functions:</b> Return a single value (e.g., integer, text).</li>
                        <li><b>Table-Valued Functions:</b> Return a table (set of rows).</li>
                        <li><b>Aggregate Functions:</b> Perform calculations on a set of values and return a single
                            value (e.g., SUM, AVG).</li>
                    </ul>
                </section>

                <section id="udf-nuances" class="new-section">
  <h3>UDF Properties in PostgreSQL</h3>
  <small>
  <table class="r-fit-text">
    <tr>
      <th>Category</th>
      <th> </th>
      <th>Meaning</th>
      <th>Example</th>
    </tr>
    <tr class="fragment">
      <td rowspan="3"><b>Volatility</b></td>
      <td><b>IMMUTABLE</b></td>
      <td>Always same result for same input<br>Can be used in indexes; precomputed</td>
      <td><code>calc_bonus(100, 0.1)</code></td>
    </tr>
    <tr class="fragment">
      <td><b>STABLE</b></td>
      <td>Same within a query, may change between queries</td>
      <td><code>current_date</code></td>
    </tr>
    <tr class="fragment">
      <td><b>VOLATILE</b></td>
      <td>May change anytime; executed as written</td>
      <td><code>random()</code>, <code>clock_timestamp()</code></td>
    </tr>
    <tr class="fragment">
      <td rowspan="3"><b>Parallel Safety</b></td>
      <td><b>PARALLEL SAFE</b></td>
      <td>Can run in parallel workers<br>No writes or global state</td>
      <td><code>calc_bonus()</code></td>
    </tr>
    <tr class="fragment">
      <td><b>PARALLEL RESTRICTED</b></td>
      <td>Allowed, but only in leader process<br>(uses cursors, temp tables)</td>
      <td>Functions with limited dependencies</td>
    </tr>
    <tr class="fragment">
      <td><b>PARALLEL UNSAFE</b></td>
      <td>Not safe in parallel (writes, sequences, side effects)</td>
      <td><code>nextval()</code>, DML functions</td>
    </tr>
  </table>
  </small>
</section>
                <section id="udf-04">
                    <h3>Pseudocode | Scalar</h3>
                    <pre><code class="language-sql">
FUNCTION double_value(x)
RETURNS number
BEGIN
    RETURN x * 2
END

            </code></pre>
                    <pre><code class="language-sql">
SELECT double_value(5) FROM TABLE  --> returns 10
            </code></pre>
                </section>
                <section id="udf-05">
                    <h3>Pseudocode | Table Valued Functions</h3>
                    <pre><code class="language-sql">
FUNCTION products_over_price(min_price)
RETURNS TABLE(product_id, product_name, price)
BEGIN
    RETURN
        SELECT id, name, price
        FROM Products
        WHERE price > min_price
END

</code></pre>
                    <pre><code class="language-sql">
CALL products_over_price(100)
--> returns a result set (multiple rows)

</code></pre>
                </section>
                <section id="udf-05">
                    <h3 class="r-fit-text">Pseudocode | Aggregate Function</h3>
                    <pre><code class="language-sql">
AGGREGATE_FUNCTION product_of_values(input_column)
RETURNS number
BEGIN
    result = 1
    FOR each value IN input_column
        result = result * value
    RETURN result
END

</code></pre>
                    <pre><code class="language-sql">
CALL product_of_values(sales.quantity)
--> returns product of all quantities

</code></pre>
                </section>

                <section id="udf-06">
                    <h3 class="r-fit-text">Creating UDFs in PostgreSQL | Scalar 1</h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION calc_discounted_price(
    p_price    NUMERIC,
    p_discount NUMERIC   -- e.g. 0.10 = 10%
)
RETURNS NUMERIC
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
AS $$
  SELECT GREATEST(
           0,
           COALESCE(p_price, 0)
           * (1 - LEAST(GREATEST(COALESCE(p_discount, 0), 0), 0.999999))
         );
$$;
                </code></pre>
                </section>
                <section id="udf-08">
  <h3 class="r-fit-text">Creating UDFs in PostgreSQL | Scalar 2</h3>
  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION order_total(p_order_id INT)
RETURNS NUMERIC
LANGUAGE sql
STABLE
PARALLEL SAFE
AS $$
  SELECT COALESCE(SUM(s.total_sales), 0)
  FROM sales s
  WHERE s.order_id = p_order_id
$$;


  </code></pre>
</section>
<section id="udf-09">
  <h3 class="r-fit-text">Creating UDFs in PostgreSQL | TVF 1</h3>
  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION top_products_by_revenue(p_limit INT)
RETURNS TABLE (
  product_id   INT,
  product_name TEXT,
  revenue      NUMERIC,
  qty          BIGINT
)
LANGUAGE sql
STABLE
AS $$
  SELECT
    p.product_id,
    p.product_name,
    COALESCE(SUM(s.total_sales), 0) AS revenue,
    COALESCE(SUM(s.quantity), 0)    AS qty
  FROM products p
  LEFT JOIN sales s ON s.product_id = p.product_id
  GROUP BY p.product_id, p.product_name
  ORDER BY revenue DESC, qty DESC, p.product_id
  LIMIT GREATEST(p_limit, 0)
$$;

  </code></pre>
</section>
                <section id="udf-07">
                    <h3 class="r-fit-text">Creating User UDFs in PostgreSQL | TVF 2</h3>
                    <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION recent_orders(
    p_customer_id INT,
    p_limit       INT
)
RETURNS TABLE (
    order_id   INT,
    order_date TIMESTAMP,
    year       INT,
    quarter    INT,
    month      TEXT,
    total      NUMERIC
)
LANGUAGE sql
STABLE
AS $$
  SELECT
      o.order_id,
      o.order_date,
      o.year,
      o.quarter,
      o.month,
      SUM(s.total_sales) AS total
  FROM orders o
  JOIN sales  s ON s.order_id = o.order_id
  WHERE s.customer_id = p_customer_id
    AND o.order_date IS NOT NULL
  GROUP BY o.order_id, o.order_date, o.year, o.quarter, o.month
  ORDER BY o.order_date DESC
  LIMIT GREATEST(p_limit, 0)
$$;

                    
                </code></pre>
                </section>

<section id="udf-07-agg">
  <h3 class="r-fit-text">Creating UDFs in PostgreSQL | Aggregate</h3>
  <small>
    Step 1: Create the state transition function
    <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION multiply_state(state NUMERIC, val NUMERIC)
RETURNS NUMERIC
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
AS $$
  SELECT COALESCE(state, 1) * COALESCE(val, 1);
$$;
    </code></pre>

    Step 2: Define the aggregate using the state function
    <pre><code class="language-sql">
CREATE AGGREGATE product_of_quantities(NUMERIC) (
  SFUNC    = multiply_state,
  STYPE    = NUMERIC,
  INITCOND = '1'
);
    </code></pre>

    
  </small>
</section>
                <section>
                <h3>Best Practices</h3>
                <ul class="r-fit-text">
                    <li>Keep UDFs small and modular</li>
                    <li>Use meaningful, action-oriented names</li>
                    <li>Validate inputs; fail fast with clear messages</li>
                    <li>Document parameters, side effects, and expected outcomes</li>
                </ul>

            </section>
            </section>
            

            
            


            <!--! UDF VS SP-->
            <section>
                <section>
                    <h3 class="new-section">UDF vs SP</h3>
                </section>
                <section class="udf-vs-sp-01">
                    <h3>UDFs vs SPs</h3>
                    <table class="r-fit-text">
                        <tr>
                            <th>Aspect</th>
                            <th>UDF (User-Defined Function)</th>
                            <th>Stored Procedure</th>
                        </tr>
                        <tr class="fragment">
                            <td><b>Return Value</b></td>
                            <td>Must return something (scalar, table, trigger)</td>
                            <td>May return nothing; focus on actions</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Usage</b></td>
                            <td>Used in <code>SELECT</code>, <code>WHERE</code>, <code>JOIN</code></td>
                            <td>Called via <code>CALL</code>; runs as a workflow</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Transaction Control</b></td>
                            <td>No COMMIT/ROLLBACK allowed</td>
                            <td>Can manage transactions explicitly</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Typical Use</b></td>
                            <td>Reusable formulas, formatting, calculations</td>
                            <td>Batch jobs, data modifications, admin tasks</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Performance</b></td>
                            <td>Can be inlined and optimized by planner</td>
                            <td>Reduces client↔DB round trips</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Security</b></td>
                            <td>Primarily for safe computations</td>
                            <td>Can act as a security boundary with EXECUTE rights</td>
                        </tr>
                    </table>

                </section>
                <section>

                    <h3>SPs, UDFs, and dbt</h3>
                    <table>
                        <tr>
                            <th>Aspect</th>
                            <th>User-Defined Function (UDF)</th>
                            <th>Stored Procedure (SP)</th>
                            <th>dbt</th>
                        </tr>
                        <tr class="fragment">
                            <td><b>Return / Output</b></td>
                            <td>Always returns (scalar, table, trigger)</td>
                            <td>May not return anything</td>
                            <td>Materializes models (tables/views)</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Use Case</b></td>
                            <td>Reusable formulas in queries</td>
                            <td>Workflows, batch jobs, transactions</td>
                            <td>Analytics pipelines, testing, lineage</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Transaction Control</b></td>
                            <td>No</td>
                            <td>Yes (COMMIT/ROLLBACK)</td>
                            <td>No (handled externally by orchestration)</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Strength</b></td>
                            <td>Compact, reusable, optimizer-friendly</td>
                            <td>Security boundary, operational workflows</td>
                            <td>Version control, CI/CD, data quality</td>
                        </tr>
                        <tr class="fragment">
                            <td><b>Best Fit</b></td>
                            <td>In-query logic & transformations</td>
                            <td>Transactional apps, admin ops</td>
                            <td>Analytics & ELT transformations</td>
                        </tr>
                    </table>

                </section>
            </section>

            <!--Practice  -->
            <section>
                <section>
                    <h3 class="new-section">Let's Practice</h3>
                </section>

                <section>
                    <h3>Our Schema</h3>
                    <img src="img/star_schema.png" alt="star schema image" , class="plain" ,>
                </section>
                <section>
                    <h3>Create DB using Docker | docker image</h3>
                    <img src="img/docker_1.jpg" alt="docker compose image" , class="plain" ,>
                </section>
                <section>
                    <h3>Create DB using Docker | services</h3>
                    <img src="img/docker_2.jpg" alt="docker compose image" , class="plain" ,>
                </section>

                <section>
                    <h3>Repo Structure</h3>
                    <pre><code class="bash"> 
.
├── README.md
├── .env                # Environment variables
├── docker-compose.yml  # Docker Compose configuration
├── img                 # screenshots
├── sql                 # sql init files
│   ├── 01_schema.sql   # building the schema
│   ├── 02_et.sql       # inserting the csv file
│   ├── 03_sps.sql # stored procedures (optional)
│   ├── 03_udfs.sql # udfs (optional)
└── docs                # Documentation assets
    ├── imgs            # Image assets for documentation
    └── index.html      # Presentation                         
                         </code></pre>
                </section>
                <section>
                    <h3>Environment Variables</h3>
                    <pre><code class="bash">  
PORT = 5432
DB_USER=admin
DB_PASSWORD=password
DB_NAME=aca
PGADMIN_EMAIL=admin@admin.com
PGADMIN_PASSWORD=admin                
                </code></pre>
                </section>
            <section>
                <h3>Build Containers</h3>
<pre><code class="bash">  
 docker-compose up --build   

</code></pre>                
            </section>
            <section>
                <h3>Stop Containers</h3>
<pre><code class="bash">  
 docker-compose down 

</code></pre>                
            </section>

            <section>
                <h3 class="r-fit-text">Create Stored Procedure | upsert product</h3>
                <p class="r-fit-text">if product exists then update the price, else insert new one</p>
                <pre><code class="sql">  
CREATE OR REPLACE PROCEDURE upsert_product(
    p_id    INT,
    p_name  TEXT,
    p_price NUMERIC,
    p_desc  TEXT,
    p_cat   TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- TODO:
    -- 1. Insert a new product with the given values
    -- 2. If the product_id already exists, update the row instead
    --    (make sure NULL inputs don't overwrite existing values)
    -- 3. Raise a NOTICE to indicate whether it was inserted or updated
END;
$$;

-- Example Tests:
-- CALL upsert_product(2001, 'USB-C Cable', 9.99, '1m braided', 'Accessories');
-- CALL upsert_product(2001, NULL, 8.99, NULL, NULL);
-- SELECT * FROM products WHERE product_id = 2001;                    
                </code></pre>
            </section>

            <section>
                <h3>Create a scalar UDF | bonus calculator</h3>
                <p class="r-fit-text">if product exists then update the price, else insert new one</p>
                <pre><code class="sql"> 
CREATE OR REPLACE FUNCTION calc_bonus(
    p_salary NUMERIC,
    p_pct    NUMERIC   -- e.g., 0.10 = 10%
)
RETURNS NUMERIC
LANGUAGE sql
AS $$
  -- TODO: return bonus = salary * pct
$$;

-- Test:
SELECT employee_id, first_name, salary, calc_bonus(salary, 0.15) AS bonus
FROM employees;                    
                     </code></pre>
            </section>


            <!-- Final Slide -->
            <section>
                <h3 class="new-section">Thank You</h3>
            </section>

            <section>
                <h3>Create a TVF | top N</h3>
                <p class="r-fit-text">Write a function that returns the top N customers by total revenue</p>
                <pre><code class="sql"> 
CREATE OR REPLACE FUNCTION top_customers(
    p_limit INT
)
RETURNS TABLE (
    customer_id   INT,
    customer_name TEXT,
    revenue       NUMERIC
)
LANGUAGE sql
AS $$
  -- TODO: aggregate total_sales from sales per customer
  -- ORDER BY revenue DESC
  -- LIMIT p_limit
$$;

-- Test:
SELECT * FROM top_customers(5);                    
                     </code></pre>
            </section>


            <!-- Final Slide -->
            <section>
                <h3 class="new-section">Thank You</h3>
            </section>
            <!-- END OF THE PRESENTATION -->
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/zoom/zoom.js"></script>
    <script src="plugin/math/math.js"></script>
    <script>
        // Full list of configuration options available at:
        // https://revealjs.com/config/
        Reveal.initialize({
            slideNumber: false,
            controls: true,
            progress: true,
            history: true,
            center: true,
            transitionSpeed: 'normal',
            previewLinks: true,
            transition: 'convex', // none/fade/slide/convex/concave/zoom


            // v4 plugin registration
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom]
        });
    </script>

    div {
    background-color: lightgrey;
    width: 300px;
    border: 15px solid green;
    padding: 50px;
    margin: 20px;
    text-align:center;
    }
    </style>
    </head>

    <body>

        <h2>Demonstrating the Box Model</h2>

        <p>borders; padding; margins; and the actual content.</p>

        <div>Some text in Div</div>

    </body>

</body>

</html>f