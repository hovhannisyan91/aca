---
title: "SQL Session 02: Intro to PostgreSQL"
categories: [SQL, Data Types, Schemas, Keys, Indexes, Syntax]
---

## Sales Analytics Database

Imagine you’ve just joined a company as a **data analyst**.  
The company sells products through an online channel and stores its operational data in a **PostgreSQL relational database**.

The database captures information about:

- customers who place orders
- products that are sold
- employees involved in the sales process
- orders placed over time
- individual sales transactions

Your role as an analyst is to **query this data** to answer business questions related to:

- revenue and sales performance
- product popularity
- customer behavior
- employee contribution
- time-based trends

---

## Learning Goals

In the previous session, you learned about different types of databases and the database management systems used to define, query, and manage them.

Without databases, you wouldn’t be able to **retrieve**, **update**, or **delete** data.  
Before analysis can begin, however, data must first be **stored**, **structured**, and **related** correctly.

In this session, we will learn about the core building blocks of a relational database:

- tables, rows, and columns
- keys and relationships
- indexes and performance trade-offs
- data types in PostgreSQL
- database schemas and analytical modeling concepts

By the end of this session, you should be able to **read and understand a relational schema** and write more efficient SQL queries.

::: {.callout-tip}
Check out [how to use pgAdmin 4](https://www.youtube.com/watch?v=E9vx7CwN2Wc) for better navigation.
:::

---

## Data Storage Structures

A **relational database** consists of **one or more tables** made up of **rows** and **columns**, and these tables are linked by **relationships**.

In this course, we will work with a **sales analytics database** that includes tables such as:

- `sales`
- `orders`
- `products`
- `customers`
- `employees`

Each table stores information about a specific business entity, and relationships between tables allow us to combine this information during analysis.

The list on the left represents all the columns in a table. Each column represents a specific attribute of a transaction, such as `total_sales`, `quantity`, or `product_id`. Each row (record) represents a **single transaction**.

![](../../img/sql/erd_extanded.png)

::: {.callout-tip}
Another name for a record is a **tuple**.

We will revisit tuples when working with Python and relational data.
:::

Tables are such a common structure that you’ve likely interacted with them without realizing it.  
For example, when you place an order on an e-commerce website like Amazon:

- **Each row** represents a different order or transaction
- **Columns** represent attributes such as:
  - customer name
  - address
  - product ordered
  - price
  - order date

To illustrate, [here’s](https://docs.google.com/spreadsheets/d/1iMX96kbFhcLIeW5TlSCEF99NMTecfx5HLW_QC5gbiqc/edit?usp=drive_link) an example order report.

---

## Keys and Indexes

To store data efficiently and enable relationships between tables, relational databases rely on **keys** and **indexes**.

### Keys

A **key** is a column (or set of columns) that uniquely identifies a row in a table.  
Keys are essential for locating records and defining relationships between tables.


If you refer back to the `sales` table, you’ll notice a key icon next to the `transaction_id` column.  
This indicates that `transaction_id` is a **key**.

In our database, each row in the `sales` table represents a **single transaction line**, uniquely identified by `transaction_id`.

![](../../img/sql/pk_sales.png)

#### Primary Key

A **primary key** uniquely identifies each record in a table.  
Each table can have **only one primary key**, and it must:

1. Be unique
2. Never be NULL
3. Remain stable when referenced by other tables

In the `sales` table, `transaction_id` is the primary key.

| transaction_id | order_id | product_id | customer_id | total_sales |
|----------------|----------|------------|-------------|-------------|
| 1001           | 501      | 12         | 3001        | 49.99       |
| 1002           | 501      | 18         | 3001        | 19.99       |
| 1003           | 502      | 12         | 3005        | 49.99       |
| 1004           | 503      | 25         | 3008        | 89.99       |

---

#### Candidate Key

A **candidate key** is any column (or set of columns) that can uniquely identify a row.

For example, in the `customers` table, `customer_id`  and `email` columns are candidate keys.

This means **both columns are candidate keys**.

From the set of candidate keys, one is chosen as the **primary key**.

In this schema, `customer_id` is selected as the primary key, while `email` remains an alternative identifier.

| **customer_id** | customer_name       | **email**                    | city     |
|-------------|---------------------|--------------------------|----------|
| 3001        | Alice Johnson       | alice.johnson@email.com  | Berlin   |
| 3002        | Mark Thompson       | mark.thompson@email.com  | Paris    |
| 3003        | Elena Petrova       | elena.p@email.com        | Madrid  |
| 3004        | David Chen          | david.chen@email.com     | London  |

---

#### Composite Key

A **composite key** is formed by combining two or more columns when no single column is sufficient to uniquely identify a row.

For example, `(order_id, product_id)` could uniquely identify rows in some transactional systems.

| order_id | product_id | product_name        | quantity |
|----------|------------|---------------------|----------|
| 501      | 12         | Wireless Mouse      | 1        |
| 501      | 18         | USB-C Cable         | 2        |
| 502      | 12         | Wireless Mouse      | 1        |
| 503      | 25         | Mechanical Keyboard | 1        |

In this table:

- `order_id` alone is **not unique**
- `product_id` alone is **not unique**
- The combination `(order_id, product_id)` uniquely identifies each row

This combination forms a **composite key**.

#### Surrogate Key

A **surrogate key** is a system-generated identifier with no business meaning.

The `transaction_id` column is a surrogate key; its only purpose is to uniquely identify each transaction.

| transaction_id | order_id | product_id | quantity | total_sales |
|----------------|----------|------------|----------|-------------|
| 1001           | 501      | 12         | 1        | 49.99       |
| 1002           | 501      | 18         | 2        | 19.99       |
| 1003           | 502      | 12         | 1        | 49.99       |
| 1004           | 503      | 25         | 1        | 89.99       |

Surrogate keys are often used even when natural or composite keys exist.

They are preferred in analytical systems because they:

- simplify joins
- reduce index size
- improve query readability
- remain stable even if business rules change

#### Foreign Key


A **foreign key** is a column (or set of columns) that references a primary key in another table.

For example, the `product_id` column in the `sales` table references the `product_id` primary key in the `products` table.  
Foreign keys establish relationships between tables and allow us to join data across entities.

Thus, Foreign key enforces **referential integrity** between the two tables which is crucial:

- prevent invalid data (e.g., sales for non-existent products)
- define how tables are related
- enable joins between tables
- preserve data consistency

![](../../img/sql/fk_sales_vs_products.png)

::: {.callout-important}
In **analytical databases**, foreign keys are sometimes not physically enforced
for performance reasons, but they are always enforced **logically** in the data model.
:::



---

## Indexes

Imagine searching through a book to find all pages starting with the letter **A**.  
Without an index, you would scan every page.  
With an index (like a dictionary), you jump directly to the correct section.

Indexes work the same way in databases.

Indexes do **not** store new data.  
They are special lookup structures that improve **query performance**.


![](../../img/sql/index.png)

::: {.callout-note title="Full Table Scan"}
When a query checks **every row** instead of using an index, this is called a **full scan**.
:::

Indexes improve read performance but come with trade-offs:

- extra storage
- slower inserts and updates
- maintenance overhead

### When Not to Create Indexes

- Very small tables
- Frequently updated columns
- Columns with many NULL values
- Columns with very low cardinality


### Single-Column Index

A **single-column index** is built on one column.

| Employee ID | Name    | Contact Number | Age |
|-------------|---------|----------------|-----|
| 1           | Max     | 800692692      | 24  |
| 2           | Jessica | 800123456      | 35  |
| 3           | Mikeal  | 800745547      | 49  |




### Composite Index

Consider the same employees table, but now imagine that queries often filter by both name and age at the same time. Thus,  **composite index** spans multiple columns, such as `(name, age)`.

Composite indexes are most effective when queries filter columns in the **same left-to-right order** as the index definition.


| employee_id | name    | age | department |
|-------------|---------|-----|------------|
| 1           | Max     | 24  | Sales      |
| 2           | Jessica | 35  | Marketing  |
| 3           | Max     | 35  | Finance    |


or an index defined as `(name, age)`:

- Efficient for queries filtering on `name`
- Efficient for queries filtering on `name` **and** `age`
- **Not efficient** for queries filtering on `age` only


For an index defined as `(name, age)`:

- Efficient for queries filtering on `name`
- Efficient for queries filtering on `name` **and** `age`
- **Not efficient** for queries filtering on `age` only
`   

### Unique Index


Unlike a regular index, a unique index enforces a rule, not just performance.
A **unique index** ensures that values are not duplicated. 


| customer_id | customer_name | email                    |
|-------------|---------------|--------------------------|
| 3001        | Alice Johnson | alice@email.com          |
| 3002        | Mark Thompson | mark@email.com           |
| 3003        | Elena Petrova | elena@email.com          |

In the aboive table:

- `email` values are unique
- No two customers share the same email address

Creating a unique index on `email`:

- prevents duplicate emails
- guarantees data integrity

Use a unique index when:

- values must be unique across rows
- the column is frequently used for lookup
- **uniqueness is part of business logic**



## Data Types

Data types define **what kind of data** a column can store.  
They ensure consistency, enable validation, and affect performance.

Consider the following example:

| Employee Name | Salary ($) |
|---------------|------------|
| Jan           | 100000     |
| Alex          | One hundred thousand |
| Kim           | 70k        |

::: {.callout-caution}

Inconsistent data types make analysis impossible.

To calculate averages or totals, the column must enforce a numeric type.
:::

---

::: {.callout-important title="Are Keys Also Indexes?"}

### Keys vs Indexes — Storage Perspective

From a **database engine and storage point of view**, keys and indexes are closely related, but they are **not the same thing**.

- A **key** defines a **logical rule** (uniqueness, relationships)
- An **index** is a **physical data structure** stored on disk to speed up access

#### How PostgreSQL Handles Them

| Concept | Enforces Uniqueness | Improves Query Speed | Stored as Index |
|-------|---------------------|----------------------|-----------------|
| Primary Key | Yes | Yes | Yes (unique index) |
| Unique Constraint | Yes | Yes | Yes (unique index) |
| Foreign Key | No | Sometimes | No (by default) |
| Regular Index | No | Yes | Yes |

#### Important Notes

- Creating a **primary key** automatically creates a **unique index**
- Creating a **unique constraint** automatically creates a **unique index**
- **Foreign keys do NOT create indexes automatically**
- Indexes exist to improve performance; keys exist to enforce rules


:::



## Data Types in PostgreSQL

1. Numeric
2. Character
3. Date & Time
4. Boolean & Categorical
5. Identifier & Auto-Increment
6. JSON and Semi-Structured
7. Array
8. Special Data Types

---

### Numeric Data Types

**Used for:** counts, quantities, prices, measurements

| Data Type | Description | Example | Use Case |
|----------|------------|---------|---------|
| `INTEGER` | Whole numbers | `2500` | Counts |
| `BIGINT` | Large integers | `9876543210` | IDs |
| `NUMERIC(p,s)` | Exact decimals | `15432.75` | Revenue |
| `DOUBLE PRECISION` | Approximate | `0.123456` | KPIs |

::: {.callout-important}
Use `NUMERIC` for money, floating-point for ratios.
:::

---

### Character Data Types

| Type | Description | Example |
|-----|------------|--------|
| `CHAR(n)` | Fixed length | `'US   '` |
| `VARCHAR(n)` | Variable length | `'Karen'` |
| `TEXT` | Unlimited | Product descriptions |

---

### Date & Time Data Types

| Type | Description | Example |
|-----|------------|--------|
| `DATE` | Date only | `2025-03-15` |
| `TIMESTAMP` | Date + time | `2025-03-15 14:30` |
| `TIMESTAMPTZ` | Time zone aware | `2025-03-15 10:30+00` |
| `INTERVAL` | Duration | `3 days` |

---

### Boolean & Categorical Data Types

| Type | Example | Use |
|-----|--------|----|
| `BOOLEAN` | `TRUE` | Flags |
| `ENUM` | `'low','medium','high'` | Categories |
| `VARCHAR` | `'premium'` | Segments |

---

### Special & Advanced Data Types

| Type | Use |
|-----|----|
| `JSONB` | Logs, APIs |
| `UUID` | Distributed IDs |
| `INET` | IP addresses |
| `GEOMETRY` | Geospatial |
| `pgRouting` | Networks |

::: {.callout-warning}
Advanced data types require specialized indexes.
:::

---

## Relational Database Schema

### What Is a Schema?

A **schema** describes the structure of a database: tables, columns, keys, and relationships.

---

### Star Schema

A **star schema** consists of:

- one central **fact table**
- multiple surrounding **dimension tables**

![](../../img/sql/star_schema.png)

::: {.callout-important}
Although our database is transactional, its structure closely resembles a star schema, making it well-suited for analytics.
:::

---

### Snowflake Schema

A **snowflake schema** extends the star schema by normalizing dimension tables into sub-dimensions.

![](../../img/sql/snowflake_schema.png)

---

### Entity Relationship Diagram (ERD)

Try to generate the ERD for the sales database using your SQL client.  
Identify primary keys, foreign keys, and relationships.

![](../../img/sql/generate_erd.png)

---

## Data Dictionary

A **data dictionary** documents metadata such as:

- table names
- column descriptions
- keys and constraints
- relationships

As an analyst, the data dictionary helps you understand where data lives and how to query it correctly.

#### Overview

This data dictionary describes the structure and meaning of the tables used in the **sales analytics database**.

It documents:

- table purpose
- column definitions
- data types
- keys and relationships

---

#### Table: `employees`

**Description**  
Stores information about employees involved in the sales process.

| Column Name | Data Type | Key | Description |
|------------|----------|-----|-------------|
| `employee_id` | `SERIAL` | PK | Unique identifier for each employee |
| `first_name` | `TEXT` |  | Employee first name |
| `last_name` | `TEXT` |  | Employee last name |
| `email` | `TEXT` |  | Employee email address |
| `salary` | `NUMERIC` |  | Employee salary |

---

#### Table: `customers`

**Description**  
Stores customer profile and location information.

| Column Name | Data Type | Key | Description |
|------------|----------|-----|-------------|
| `customer_id` | `INTEGER` | PK | Unique identifier for each customer |
| `customer_name` | `TEXT` |  | Full customer name |
| `address` | `TEXT` |  | Customer address |
| `city` | `TEXT` |  | City of residence |
| `zip_code` | `TEXT` |  | Postal / ZIP code |

---

#### Table: `products`

**Description**  
Contains product catalog information.

| Column Name | Data Type | Key | Description |
|------------|----------|-----|-------------|
| `product_id` | `INTEGER` | PK | Unique product identifier |
| `product_name` | `TEXT` |  | Name of the product |
| `price` | `NUMERIC` |  | Unit price of the product |
| `description` | `TEXT` |  | Product description |
| `category` | `TEXT` |  | Product category |

---

#### Table: `orders`

**Description**  
Stores order-level information and time attributes.

| Column Name | Data Type | Key | Description |
|------------|----------|-----|-------------|
| `order_id` | `INTEGER` | PK | Unique order identifier |
| `order_date` | `TIMESTAMP` |  | Date and time when the order was placed |
| `year` | `INTEGER` |  | Order year (derived) |
| `quarter` | `INTEGER` |  | Order quarter (derived) |
| `month` | `TEXT` |  | Order month name (derived) |

---

#### Table: `sales`

**Description**  
Central fact table storing individual sales transaction lines.

| Column Name | Data Type | Key | Description |
|------------|----------|-----|-------------|
| `transaction_id` | `INTEGER` | PK | Unique transaction identifier (surrogate key) |
| `order_id` | `INTEGER` | FK | References `orders(order_id)` |
| `product_id` | `INTEGER` | FK | References `products(product_id)` |
| `customer_id` | `INTEGER` | FK | References `customers(customer_id)` |
| `employee_id` | `INTEGER` | FK | References `employees(employee_id)` |
| `total_sales` | `NUMERIC` |  | Total sales value for the transaction |
| `quantity` | `INTEGER` |  | Number of units sold |
| `discount` | `NUMERIC` |  | Discount applied to the transaction |

---

#### Relationships Summary

| From Table | Column | To Table | Column | Relationship Type |
|-----------|--------|----------|--------|-------------------|
| `sales` | `order_id` | `orders` | `order_id` | Many-to-one |
| `sales` | `product_id` | `products` | `product_id` | Many-to-one |
| `sales` | `customer_id` | `customers` | `customer_id` | Many-to-one |
| `sales` | `employee_id` | `employees` | `employee_id` | Many-to-one |

---

#### Indexes

| Index Name | Table | Column(s) | Purpose |
|-----------|------|-----------|--------|
| `idx_sales_order_id` | `sales` | `order_id` | Speed up joins with orders |
| `idx_sales_product_id` | `sales` | `product_id` | Speed up product analysis |
| `idx_sales_customer_id` | `sales` | `customer_id` | Speed up customer analysis |
| `idx_orders_date` | `orders` | `order_date` | Speed up time-based queries |

---

#### Analyst Notes

- `sales` is the **fact table**
- Other tables act as **dimensions**
- `transaction_id` is a **surrogate key**
- Time attributes are intentionally **denormalized**
- Foreign keys may be **logically enforced** in analytical systems